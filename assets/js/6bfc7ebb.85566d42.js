"use strict";(self.webpackChunkictf_docs=self.webpackChunkictf_docs||[]).push([[2310],{5335:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var s=r(4848),o=r(8453);const t={},i=void 0,a={id:"challenges/who-is-waldo/solution.py",title:"solution.py",description:"",source:"@site/docs/challenges/who-is-waldo/solution.py.mdx",sourceDirName:"challenges/who-is-waldo",slug:"/challenges/who-is-waldo/solution.py",permalink:"/ictf-docs/challenges/who-is-waldo/solution.py",draft:!1,unlisted:!1,editUrl:"https://github.com/ucsb-seclab/ictf-docs/tree/main/docs/challenges/who-is-waldo/solution.py.mdx",tags:[],version:"current",frontMatter:{},sidebar:"challenges",previous:{title:"Who is Waldo?",permalink:"/ictf-docs/challenges/who-is-waldo/"}},l={},d=[];function c(n){const e={code:"code",pre:"pre",...(0,o.R)(),...n.components};return(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'import torch as ch\r\nimport os\r\nfrom tqdm import tqdm\r\nfrom torch.utils.data import Dataset\r\nfrom PIL import Image\r\nfrom torch.autograd import Variable\r\nfrom torchvision import transforms\r\nimport numpy as np\r\nfrom torchvision.models import efficientnet_b1\r\n\r\n\r\ndef main():\r\n    model = efficientnet_b1(weights="DEFAULT")\r\n    transform = transforms.Compose(\r\n        [\r\n            transforms.Resize(255, interpolation=2),\r\n            transforms.CenterCrop(240),\r\n            transforms.ToTensor(),\r\n            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\r\n        ]\r\n    )\r\n    # Replace model.classifier to have Linear layer\r\n    model.classifier = ch.nn.Linear(1280, 1)\r\n\r\n    # Load model\r\n    model.load_state_dict(ch.load("model.pth"))\r\n    model.cuda()\r\n    model.eval()\r\n\r\n    # Read friends from file (I knew when I trained the model!)\r\n    with open("waldo.txt", "r") as f:\r\n        # One line, comma separated\r\n        for line in f:\r\n            friends = list(map(int, line.rstrip("\\n").split(",")))\r\n\r\n    loss_fn = ch.nn.BCEWithLogitsLoss(reduction="none")\r\n\r\n    scores = []\r\n    for id in tqdm(os.listdir("data"), total=500):\r\n        all_images, all_labels = [], []\r\n        for path in os.listdir(os.path.join("data", id)):\r\n            # Load image\r\n            img = Image.open(os.path.join("data", id, path))\r\n            img = transform(img)\r\n            label = int(path.split(".jpg")[0].split("_")[1])\r\n            all_images.append(img)\r\n            all_labels.append(label)\r\n        # Convert to tensors\r\n        all_images = ch.stack(all_images).cuda()\r\n        all_labels = ch.tensor(all_labels).cuda()\r\n\r\n        # Loss-based\r\n        logits = model(all_images)[:, 0]\r\n        loss = loss_fn(logits.squeeze(), all_labels.float())\r\n        # score = loss.mean().item() # Mean\r\n        # score = (loss.max() - loss.min()).item() # Range based\r\n        score = loss.min().item()  # Min based\r\n        # score = loss.median().item() # Median based\r\n        # score = loss.max().item()  # Max based\r\n        # score = ch.std(loss).item() # Std based\r\n        scores.append(score)\r\n\r\n        # Average gradient norm-based\r\n        # model.zero_grad()\r\n        # loss.backward(ch.ones_like(loss), retain_graph=True)\r\n        # Get average gradient norm\r\n        # grads = []\r\n        # for param in model.parameters():\r\n        # grads.append(param.grad.norm().item())\r\n        # score = np.mean(grads)\r\n\r\n    scores = np.array(scores)\r\n    # Sort and pick IDs with 100 lowest scores\r\n    sorted_ids = np.argsort(scores)\r\n    picked_ids = np.sort(sorted_ids[:10])\r\n\r\n    # Check recall of this (how many out of sorted_ids are in friends?)\r\n    identified_friends = set(picked_ids).intersection(set(friends))\r\n    print(f"Attack identified {len(identified_friends)} out of {len(friends)} friends")\r\n    return sorted(identified_friends)\r\n\r\n\r\nif __name__ == "__main__":\r\n    picked_ids = main()\r\n    print(picked_ids)\r\n    # flag = \'ictf{\' + ",".join([str(x) for x in picked_ids]) + \'}\'\r\n    # Print out regex corresponding to these IDs\n'})})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>a});var s=r(6540);const o={},t=s.createContext(o);function i(n){const e=s.useContext(t);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);