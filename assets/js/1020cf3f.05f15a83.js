"use strict";(self.webpackChunkictf_docs=self.webpackChunkictf_docs||[]).push([[2334],{3524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=n(4848),o=n(8453);const a={title:"rustyneurone",sidebar_custom_props:{levels:["UG"]}},s=void 0,r={id:"writeups/rustyneurone/index",title:"rustyneurone",description:"Introduction",source:"@site/docs/writeups/rustyneurone/index.md",sourceDirName:"writeups/rustyneurone",slug:"/writeups/rustyneurone/",permalink:"/ictf-docs/writeups/rustyneurone/",draft:!1,unlisted:!1,editUrl:"https://github.com/ucsb-seclab/ictf-docs/tree/main/docs/writeups/rustyneurone/index.md",tags:[],version:"current",frontMatter:{title:"rustyneurone",sidebar_custom_props:{levels:["UG"]}},sidebar:"writeups",previous:{title:"exploit.py",permalink:"/ictf-docs/writeups/printbof/exploit.py"},next:{title:"Snake Game",permalink:"/ictf-docs/writeups/snake-game/"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Challenge analysis",id:"challenge-analysis",level:2},{value:"Exploitation",id:"exploitation",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"rustyneurone"})," is a challenge written in Rust. The challenge simulates how a classical neuron used by a neural network operates."]}),"\n",(0,i.jsxs)(t.p,{children:["The challenge is exploitable since it contains some unsafe usage of Rust (marked ",(0,i.jsx)(t.code,{children:"unsafe"})," in the Rust source code).\nThe unsafe code leads both to memory on the stack being leaked and to stack memory being overwritten, enabling standard ROP-chain-based exploitation."]}),"\n",(0,i.jsx)(t.h2,{id:"challenge-analysis",children:"Challenge analysis"}),"\n",(0,i.jsxs)(t.p,{children:["The challenge asks for a list of weights, a list of inputs, a bias, one hyperbias, and an activation function (to be chosen among ",(0,i.jsx)(t.code,{children:"tanh"}),", ",(0,i.jsx)(t.code,{children:"sigmoid"}),", and ",(0,i.jsx)(t.code,{children:"GELU"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["After the neuron's configuration is provided, the challenge prints out the provided weights and the final computed value, performing standard neural network math (check here for a ",(0,i.jsx)(t.a,{href:"https://medium.com/coinmonks/the-mathematics-of-neural-network-60a112dd3e05",children:"tutorial"}),"). The code operates in a loop, allowing the user to simulate a neuron's behavior multiple times."]}),"\n",(0,i.jsx)(t.p,{children:"By manual testing and reverse engineering, one can notice that:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The weights printed back to the user do not always match what provided. Upon further inspection one can realize that weights printed back can leak values from the stack (encoded as floating point numbers)."}),"\n",(0,i.jsx)(t.li,{children:"The hyperbias is not really used in the computation of the final results (indeed, there is no such thing as a hyperbias in standard neurons). However, it is used to determine where the final results of the neuron simulation is written on the stack."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"exploitation",children:"Exploitation"}),"\n",(0,i.jsx)(t.p,{children:"Exploiting point 1, it is possible to leak part of the content of the stack. In particular the value printed as Weight #6 leaks the location of the main binary in memory."}),"\n",(0,i.jsx)(t.p,{children:"Exploiting point 2, it is possible to write a ROP-chain on the stack. Specifically, for each neuron simulation we can write 8 bytes on the stack, controlling the location on the stack using different values for the hyperbias."}),"\n",(0,i.jsx)(t.p,{children:"In particular, the values written on the stack are the results of each neuron simulation. Hence, to control them, we need to provide proper values to the neuron so that its output is what we desire. This is not particularly hard. In fact, we can provide a list of zeros for both the inputs and the weights effectively making the input of the neuron's activation function equal to only the neuron's bias. Then, we can choose an activation function that does not modify its input, so that the provided value for the bias will be equal to the output of the neuron and directly written to the stack."}),"\n",(0,i.jsxs)(t.p,{children:["To this aim, when we need to write to the stack small values (i.e., 8-byte sequences that, when encoded as a floating point number, translate to a small value), we can use the ",(0,i.jsx)(t.code,{children:"tanh"})," activation function. On the contrary, when we need to write to the stack large values, we can use the ",(0,i.jsx)(t.code,{children:"GELU"})," activation function. Mathematically, this works because these two functions can be approximated to the identify function for values near 0 and for values near to plus infinitive, respectively."]}),"\n",(0,i.jsxs)(t.p,{children:["By exploiting the method explained above, we can corrupt the saved return address and write an entire ROP-chain on the stack (e.g., a ROP-chain opening a shell). The ROP-chain will be triggered by making the program exit the main neuron simulation loop and return from its ",(0,i.jsx)(t.code,{children:"main"})," function."]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);